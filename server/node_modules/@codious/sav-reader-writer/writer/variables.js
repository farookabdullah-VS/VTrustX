// REQUIRES
const moment = require('moment');

const { buffer, BufferType } = require('../utilities');
const { version } = require('../package.json');


// PRIVATE PROPERTIES
const alignments = Object.freeze({ Centre: 2, Left: 0, Right: 1 });
const measures = Object.freeze({ Continuous: 3, Nominal: 1, Ordinal: 2 });
const types = Object.freeze({ Date: 20, DateTime: 22, Numeric: 5, String: 1 });


// PUBLIC PROPERTIES
module.exports.alignments = alignments;
module.exports.measures = measures;
module.exports.types = types;


// PUBLIC METHODS
module.exports.toArray = function(variables, ncases, { bias }) {
  validate(variables);
  shortNames(variables);
  return [
    fileHeaderRecord(variables, ncases, bias),
    variableRecord(variables),
    valueLabelsRecord(variables),
    machineIntegerInfoRecord(),
    machineFloatingPointInfoRecord(),
    variableDisplayParameterRecord(variables),
    longVariableNamesRecord(variables),
    longStringValueLabelsRecord(variables),
    characterEncodingRecord(),
    dictionaryTerminationRecord(),
  ].flat();
};


// PRIVATE METHODS
function characterEncodingRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 20 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: 5 }, // count
    { type: BufferType.String, value: 'UTF-8' }, // encoding
  ];
}

function dictionaryTerminationRecord() {
  return [
    { type: BufferType.Int32, value: 999 }, // rec_type
    { type: BufferType.Int32, value: 0 }, // filler
  ];
}

function fileHeaderRecord(variables, ncases, bias) {
  return [
    { type: BufferType.String, value: '$FL2' }, // rec_type[4]
    { length: 60, type: BufferType.String, value: `@(#) SPSS DATA FILE - @CODIOUS/SAV-WRITER ${version}` }, // prod_name[60]
    { type: BufferType.Int32, value: 2 }, // layout_code
    { type: BufferType.Int32, value: variables.map((v) => (v.type === types.String ? Math.ceil(v.width / 8) : 1)).reduce((a, b) => a + b) }, // nom_case_size
    { type: BufferType.Int32, value: 1 }, // compression
    { type: BufferType.Int32, value: 0 }, // weight_index
    { type: BufferType.Int32, value: ncases }, // ncases
    { type: BufferType.Float, value: bias }, // bias
    { type: BufferType.String, value: moment().format('DD MMM YY') }, // creation_date[9]
    { type: BufferType.String, value: moment().format('HH:mm:ss') }, // creation_time[8]
    { length: 64, type: BufferType.String, value: `FILE GENERATED BY @CODIOUS/SAV-WRITER ${version}` }, // file_label[64]
    { type: BufferType.Int8, value: 0 }, // padding
    { type: BufferType.Int8, value: 0 }, // padding
    { type: BufferType.Int8, value: 0 }, // padding
  ];
}

function longStringValueLabelsRecord(variables) {
  const valueLabels = buffer.write(variables.map((variable) => {
    if (!variable.valueLabels || !variable.valueLabels.length) return undefined;
    if (variable.type !== types.String || Math.ceil(variable.width / 8) === 1) return undefined;
    return [
      { type: BufferType.Int32, value: variable.short.length }, // var_name_length
      { type: BufferType.String, value: variable.short }, // var_name[]
      { type: BufferType.Int32, value: variable.width }, // var_width
      { type: BufferType.Int32, value: variable.valueLabels.length }, // n_labels
    ].concat(...variable.valueLabels.map(({ label, value }) => ([
      { type: BufferType.Int32, value: variable.width }, // value_len
      { length: variable.width, type: BufferType.String, value }, // value[]
      { type: BufferType.Int32, value: label.length }, // label_len
      { type: BufferType.String, value: label }, // label[]
    ])));
  }).filter((valueLabel) => !!valueLabel).flat());
  return valueLabels.length ? [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 21 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: valueLabels.length }, // count
    { type: BufferType.Buffer, value: valueLabels }, // var_value_labels[]
  ] : [];
}

function longVariableNamesRecord(variables) {
  const pairs = buffer.write(variables.map((variable) => [
    { type: BufferType.String, value: variable.short }, // var
    { type: BufferType.String, value: '=' }, // equals
    { type: BufferType.String, value: variable.name }, // name
    { type: BufferType.Int8, value: 9 }, // separator
  ]).flat().slice(0, -1));
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 13 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: pairs.length }, // count
    { type: BufferType.Buffer, value: pairs }, // var_name_pairs[]
  ];
}

function machineFloatingPointInfoRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 4 }, // subtype
    { type: BufferType.Int32, value: 8 }, // size
    { type: BufferType.Int32, value: 3 }, // count
    { type: BufferType.Float, value: -Number.MAX_VALUE }, // sysmis
    { type: BufferType.Float, value: Number.MAX_VALUE }, // highest
    { type: BufferType.Float, value: -Number.MAX_VALUE }, // lowest
  ];
}

function machineIntegerInfoRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 3 }, // subtype
    { type: BufferType.Int32, value: 4 }, // size
    { type: BufferType.Int32, value: 8 }, // count
    { type: BufferType.Int32, value: 1 }, // version_major
    { type: BufferType.Int32, value: 2 }, // version_minor
    { type: BufferType.Int32, value: 0 }, // version_revision
    { type: BufferType.Int32, value: -1 }, // machine_code
    { type: BufferType.Int32, value: 1 }, // floating_point_rep
    { type: BufferType.Int32, value: 1 }, // compression_code
    { type: BufferType.Int32, value: 2 }, // endianness
    { type: BufferType.Int32, value: 65001 }, // character_code
  ];
}

function shortNames(variables) {
  variables.forEach((variable) => {
    let index = 0;
    let short = variable.name.toUpperCase().substring(0, 8);
    const shorts = variables.map((v) => v.short);
    while (shorts.includes(short)) {
      index += 1;
      short = `${short.slice(0, short.length - index.toString().length)}${index}`;
    }
    variable.short = short; // eslint-disable-line no-param-reassign
  });
}

function validate(variables) {
  variables.forEach((variable) => {
    if (!variable.name || !variable.name.length) throw new Error('Variable name can\'t be empty.');
    if (variable.name.length > 64) throw new Error('Variable name can\'t exceed 64 characters.');
    if (!variable.name.match(/^[a-z@][a-z0-9!._#@$]*[^.]$/i)) throw new Error('Variable name doesn\'t meet the SPSS requirements.');
    if (!variable.type) throw new Error('Variable type can\'t be empty.');
    Object.assign(variable,
      { alignment: variable.alignment || alignments.Right, label: variable.label || variable.name, measure: variable.measure || measures.Continuous });
    switch (variable.type) { // eslint-disable-line default-case
      case types.Date: Object.assign(variable, { columns: 10, decimal: 0, width: 10 }); break;
      case types.DateTime: Object.assign(variable, { columns: 19, decimal: 0, width: 19 }); break;
      case types.Numeric:
        Object.assign(variable, { decimal: variable.decimal === undefined ? 2 : variable.decimal, width: variable.width || 8 });
        Object.assign(variable, { columns: variable.columns || variable.decimal + variable.width });
        break;
      case types.String: Object.assign(variable, { columns: variable.width || 8, decimal: 0, width: variable.width || 8 }); break;
    }
    if (variable.decimal < 0 || variable.decimal > 16) throw new Error('Variable decimal must be between 0 and 16.');
    if (variable.width < 0 || variable.width > 32767) throw new Error('Variable width must be between 0 and 32767.');
    if (variable.type !== types.String && variable.width > 40) throw new Error(`Variable width must be between 1 and 40 for type ${variable.type}.`);
    if (variable.width <= variable.decimal) throw new Error('Variable width can\'t be less or equal to variable decimal.');
  });
}

function valueLabelsRecord(variables) {
  let index = 0;
  return variables.map((variable) => {
    index += variable.type === types.String ? Math.ceil(variable.width / 8) : 1;
    if (!variable.valueLabels || !variable.valueLabels.length) return undefined;
    if (variable.type === types.String && Math.ceil(variable.width / 8) > 1) return undefined;
    return [
      { type: BufferType.Int32, value: 3 }, // rec_type
      { type: BufferType.Int32, value: variable.valueLabels.length }, // label_count
    ].concat(...variable.valueLabels.map(({ label, value }) => ([
      (variable.type === types.Numeric && { type: BufferType.Float, value: +value }) || { length: 8, type: BufferType.String, value }, // value[8]
      { type: BufferType.Int8, value: Math.min(label.length, 255) }, // label_len
      { length: Math.min(Math.ceil(label.length / 8) * 8 - 1, 255), type: BufferType.String, value: label }, // label[]
    ]))).concat([
      { type: BufferType.Int32, value: 4 }, // rec_type
      { type: BufferType.Int32, value: 1 }, // var_count
      { type: BufferType.Int32, value: index }, // vars[]
    ]);
  }).filter((variable) => !!variable).flat();
}

function variableDisplayParameterRecord(variables) {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 11 }, // subtype
    { type: BufferType.Int32, value: 4 }, // size
    { type: BufferType.Int32, value: variables.length * 3 }, // count
  ].concat(...variables.map((variable) => ([
    { type: BufferType.Int32, value: variable.measure }, // measure
    { type: BufferType.Int32, value: variable.columns }, // columns
    { type: BufferType.Int32, value: variable.alignment }, // alignment
  ])));
}

function variableRecord(variables) {
  return variables.map((variable) => [
    { type: BufferType.Int32, value: 2 }, // rec_type
    { type: BufferType.Int32, value: variable.type === types.String ? variable.width : 0 }, // type
    { type: BufferType.Int32, value: variable.label && variable.label.length ? 1 : 0 }, // has_var_label
    { type: BufferType.Int32, value: 0 }, // n_missing_values
    { type: BufferType.Int32, value: variable.type * 65536 + variable.width * 256 + variable.decimal }, // print
    { type: BufferType.Int32, value: variable.type * 65536 + variable.width * 256 + variable.decimal }, // write
    { length: 8, type: BufferType.String, value: variable.short }, // name[8]
    { type: BufferType.Int32, value: variable.label.length }, // label_len
    { length: Math.ceil(variable.label.length / 4) * 4, type: BufferType.String, value: variable.label }, // label[]
  ].concat(...variable.type === types.String ? Array.from({ length: Math.ceil(variable.width / 8) - 1 }).map(() => [
    { type: BufferType.Int32, value: 2 }, // rec_type
    { type: BufferType.Int32, value: -1 }, // type
    { type: BufferType.Float, value: 0 }, // ignored
    { type: BufferType.Float, value: 0 }, // ignored
    { type: BufferType.Float, value: 0 }, // ignored
  ]) : [])).flat();
}